## Platform Error Runbook

This document classifies common platform/runtime errors (e.g., a hosting provider like Vercel/Netlify/Cloudflare) and lists practical remediation steps you can apply from the project codebase or from your hosting dashboard.

NOTE: The repository in this workspace appears to be a static site (no serverless functions in `src/script/main.js`). Most errors below are generated by the hosting platform and are not produced by static client code. Use this runbook to map an observed error to likely root causes and fixes.

---

### How to use
- When you see an error code in production logs or in the platform dashboard, search the dashboard logs for the exact event/time and copy the full request/response. Then use this document to map to likely causes.
- If the error is reproducible locally, add the failing request and attach logs to a support ticket for the hosting provider.

---

### Categories and Examples (from your list)

- Functions / Edge / Middleware
  - EDGE_FUNCTION_INVOCATION_FAILED (500)
  - FUNCTION_INVOCATION_FAILED (500)
  - FUNCTION_INVOCATION_TIMEOUT (504)
  - FUNCTION_PAYLOAD_TOO_LARGE (413)
  - FUNCTION_RESPONSE_PAYLOAD_TOO_LARGE (500)
  - FUNCTION_THROTTLED (503)
  - MIDDLEWARE_INVOCATION_FAILED / TIMEOUT (500 / 504)
  - NO_RESPONSE_FROM_FUNCTION (502)
  - MICROFRONTENDS_MIDDLEWARE_ERROR (500)
  - INFINITE_LOOP_DETECTED (508)

  Typical root causes & fixes:
  - Your serverless function returned a non-string/non-serializable body. Ensure you return a string or JSON with proper headers (Content-Type: application/json or text/html). Example (Node):
    - `return new Response(JSON.stringify(data), { status: 200, headers: { 'Content-Type': 'application/json' } })`
  - Long-running sync code or recursion → increase timeout or refactor to smaller steps. Add timeouts, avoid synchronous infinite loops.
  - Payload too large: stream responses, paginate data, or return signed URLs for large files instead of inlining binary data.
  - Throttling: add retry/backoff, reduce concurrency, enable provider's scaling options.
  - Add defensive try/catch around main handler and log errors with a unique request id.

- Routing / Sandbox / Deployment / DNS
  - DEPLOYMENT_BLOCKED / DEPLOYMENT_DELETED / DEPLOYMENT_DISABLED / DEPLOYMENT_NOT_FOUND / DEPLOYMENT_PAUSED
  - ROUTER_CANNOT_MATCH (502)
  - ROUTER_EXTERNAL_TARGET_CONNECTION_ERROR / HANDSHAKE_ERROR / EXTERNAL_TARGET_ERROR (502)
  - SANDBOX_NOT_FOUND / SANDBOX_NOT_LISTENING / SANDBOX_STOPPED
  - DNS_HOSTNAME_EMPTY / DNS_HOSTNAME_NOT_FOUND / DNS_HOSTNAME_RESOLVE_FAILED / DNS_HOSTNAME_RESOLVED_PRIVATE / DNS_HOSTNAME_SERVER_ERROR

  Typical root causes & fixes:
  - Deployment or environment misconfiguration: check your hosting dashboard for a failed deployment, missing env variables, or deleted/paused deployment.
  - DNS misconfiguration: verify A/AAAA/CNAME records, TTLs and that the domain points to the provider's edge. Use `nslookup`/`dig` to confirm resolution.
  - Router can't match: ensure your routing rules (rewrites, redirects, headers) are correctly set and don't conflict. Check any `vercel.json`/`netlify.toml`/edge config.

- Request / Headers / Range / URL
  - INVALID_REQUEST_METHOD (405)
  - MALFORMED_REQUEST_HEADER (400)
  - REQUEST_HEADER_TOO_LARGE (431)
  - RANGE_* (416)
  - URL_TOO_LONG (414)

  Typical root causes & fixes:
  - Client sends unexpected method or malformed headers. Validate request shape server-side and return clear 4xx responses.
  - Avoid extremely large headers (cookies or JWTs). Use server-side session storage or shorten cookies.
  - For Range errors, validate the `Range:` header and return 416 when inappropriate.
  - If you generate very long URLs (query strings), switch to POST or use shorter IDs.

- Image optimization / External assets
  - INVALID_IMAGE_OPTIMIZE_REQUEST (400)
  - OPTIMIZED_EXTERNAL_IMAGE_REQUEST_* (502)

  Typical root causes & fixes:
  - Provider image optimizer failed: ensure remote image is accessible (not blocked by CORS/auth). Use a proxy or fetch + cache on your edge.
  - Too many redirects on image URL: fix the remote host or use a different source.

- Cache / Edge / Limits
  - FALLBACK_BODY_TOO_LARGE (502)
  - TOO_MANY_FILESYSTEM_CHECKS (502)
  - TOO_MANY_FORKS / TOO_MANY_RANGES / TOO_MANY_FILESYSTEM_CHECKS (502)

  Typical root causes & fixes:
  - Response or fallback is larger than the provider cache limit. Reduce size, use streaming, or use an object store (S3) and return a small redirect.
  - Avoid expensive filesystem operations in edge runtimes; pre-bake/build assets into the deployment.

---

### Quick actionable checklist for this repo

1. Confirm whether you use any serverless functions / middleware on the hosting platform (Edge functions, serverless API routes). If not, most runtime errors will be platform-related and not caused by `main.js`.

2. If you do have functions, ensure:
   - Handlers always return a proper Response/string/JSON.
   - Add try/catch and return 500 with a consistent JSON error shape.
   - Limit response size and stream large payloads instead of embedding them.
   - Avoid creating very large cookies or response headers.

3. DNS & Deployment:
   - Verify domain DNS records with your hosting provider's docs and `nslookup`/`dig`.
   - Check the deployment status/history in your hosting dashboard for paused/blocked/deleted errors.

4. Image optimizer:
   - If using provider image optimization, ensure external images are reachable and don't redirect excessively.

5. Logging & tracing:
   - Add unique request ids to serverless logs and enable tracing (if provider supports it).
   - Reproduce the failure and attach timestamps + request ids to provider support tickets.

---

### Example fixes (serverless Node/Edge handler patterns)

1) Safe JSON response (Edge/Cloudflare style):

```js
export default async function handler(request) {
  try {
    const data = { ok: true };
    return new Response(JSON.stringify(data), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (err) {
    console.error('handler error', err);
    return new Response(JSON.stringify({ error: 'internal_server_error' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }
}
```

2) Limit payloads: paginate or stream large datasets; never return raw large files from functions—use signed storage links.

---

### When to contact hosting support

- If you see 5xx errors with provider internals (e.g., SANDBOX_NOT_FOUND, DEPLOYMENT_BLOCKED) and you cannot map them to your deployment logs, contact support and attach a) timestamped logs b) request id c) reproduction steps.

---

If you want, I can:
- scan this repo for serverless function files (API or `functions/` folder) and add protective wrappers to any found handlers, or
- generate a short `docs/DEPLOYMENT_RUNBOOK.md` with example platform commands and diagnostic `curl`/`dig` checks to run locally.

Tell me which you'd prefer and I'll proceed.
